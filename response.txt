**1. Problem Understanding**

For each test case, we first build a deterministic sorted lineup:

- Create pairs $(a_i, i)$ for $i=1..n$.
- Sort by increasing $a_i$, and if equal, by increasing $i$.
- Let the resulting sorted aura values be $v_0, v_1, \dots, v_{n-1}$.

Next, we construct an order $p_1..p_n$ by choosing a start index in $v$ and then repeatedly taking an element adjacent to the already-taken block. Therefore, after any $k$ steps, the taken indices in $v$ form a contiguous interval $[L,R]$ with length $k$.

For each prefix $p_1..p_i$, define:
- $\min_i=\min(p_1..p_i)$
- $\max_i=\max(p_1..p_i)$

The score is:
$$
\text{Score}(p)=\sum_{i=1}^{n} w_i\cdot(\max_i-\min_i).
$$

We must maximize this score over all valid constructions of $p$.

Key observation: since $v$ is sorted, if the taken set corresponds to interval $[L,R]$, then $\min=v_L$ and $\max=v_R$, so the spread is exactly $v_R-v_L$.

---

**2. Optimal Approach**

We use dynamic programming over intervals of the sorted array $v$.

State idea:
- Any valid partial process corresponds to some interval $[L,R]$ in $v$.
- Its length is $\text{len}=R-L+1$ and its spread is $v_R-v_L$.

Incremental scoring:
- When we expand an interval from length $\text{len}$ to $\text{len}+1$, we add exactly one new term to the sum: the one for prefix length $\text{len}+1$.
- If the new interval is $[L',R']$, the added value is
$$
w_{\text{len}+1}\cdot(v_{R'}-v_{L'}).
$$

Transitions from $[L,R]$:
- Expand left (if $L>0$): new interval $[L-1,R]$, added spread $v_R-v_{L-1}$.
- Expand right (if $R<n-1$): new interval $[L,R+1]$, added spread $v_{R+1}-v_L$.

Implementation detail (memory optimization):
- Process intervals by increasing length.
- For a fixed length `current_length`, store values in a 1D array
  `current_dp[left_index]`, representing interval
  $[L,R]=[\text{left_index}, \text{left_index}+\text{current_length}-1]$.
- Build `next_dp` for length `current_length + 1`.

Initialization:
- For length $1$, spread is $0$, so all starting states have score $0$.

Answer:
- After reaching length $n$, the only interval is $[0,n-1]$, stored at
  `current_dp[0]`.

---

**3. Code**
```python
import sys


def solve_test_case(artifact_auras: list[int], prefix_weights: list[int]) -> int:
    """
    Compute the maximum achievable weighted score for one test case.

    The algorithm:
    1) Build the deterministic sorted lineup v from (a_i, i).
    2) Run interval DP where each state is a contiguous segment [L, R] of v,
       grown by one element per step.

    Args:
        artifact_auras: Aura values a_1..a_n.
        prefix_weights: Weights w_1..w_n (may be negative).

    Returns:
        The maximum possible score as an integer.
    """
    artifact_count = len(artifact_auras)
    if artifact_count == 1:
        return 0

    sorted_pairs = sorted(
        (artifact_auras[position], position)
        for position in range(artifact_count)
    )
    sorted_auras = [aura_value for aura_value, _ in sorted_pairs]

    negative_infinity = -10**60

    current_dp = [0] * artifact_count

    for current_length in range(1, artifact_count):
        weight_value = prefix_weights[current_length]
        next_dp_size = artifact_count - current_length
        next_dp = [negative_infinity] * next_dp_size

        left_index_limit = artifact_count - current_length + 1
        for left_index in range(left_index_limit):
            current_score = current_dp[left_index]
            if current_score == negative_infinity:
                continue

            right_index = left_index + current_length - 1

            if left_index > 0:
                new_left_index = left_index - 1
                new_spread = (
                    sorted_auras[right_index] - sorted_auras[new_left_index]
                )
                candidate_score = current_score + weight_value * new_spread
                if candidate_score > next_dp[new_left_index]:
                    next_dp[new_left_index] = candidate_score

            if right_index + 1 < artifact_count:
                new_spread = (
                    sorted_auras[right_index + 1] - sorted_auras[left_index]
                )
                candidate_score = current_score + weight_value * new_spread
                if candidate_score > next_dp[left_index]:
                    next_dp[left_index] = candidate_score

        current_dp = next_dp

    return current_dp[0]


def main() -> None:
    """
    Read input, solve all test cases, and print the result for each one.

    Input:
        t
        n
        a_1..a_n
        w_1..w_n
        (repeated t times)

    Output:
        For each test case, one line with the maximum achievable score.
    """
    tokens = sys.stdin.buffer.read().split()
    token_index = 0

    test_count = int(tokens[token_index])
    token_index += 1

    output_lines: list[str] = []

    for _ in range(test_count):
        artifact_count = int(tokens[token_index])
        token_index += 1

        artifact_auras = [
            int(tokens[token_index + offset])
            for offset in range(artifact_count)
        ]
        token_index += artifact_count

        prefix_weights = [
            int(tokens[token_index + offset])
            for offset in range(artifact_count)
        ]
        token_index += artifact_count

        output_lines.append(
            str(solve_test_case(artifact_auras, prefix_weights))
        )

    sys.stdout.write("\n".join(output_lines))


if __name__ == "__main__":
    main()
```

---

**4. Code Explanation**

- `sorted_auras` is the deterministic lineup $v$ after sorting $(a_i,i)$.
- The DP is processed by interval length.
  - For a fixed `current_length`, `current_dp[left_index]` stores the best score
    for the interval
    $[L,R]=[\text{left_index}, \text{left_index}+\text{current_length}-1]$.
- When moving from length `current_length` to `current_length + 1`, we add the
  contribution of prefix length `current_length + 1`.
  - With 0-based lists, that weight is `prefix_weights[current_length]`,
    corresponding to $w_{\text{len}+1}$.
- Two expansions are considered:
  - Expand left (if possible): new spread is $v_R - v_{L-1}$.
  - Expand right (if possible): new spread is $v_{R+1} - v_L$.
- The answer is `current_dp[0]` after all lengths are processed, which
  represents the full interval $[0,n-1]$.

---

**5. Time and Space Complexity**

Let $n$ be the number of artifacts.

- Sorting: $O(n\log n)$
- DP: there are $O(n^2)$ intervals processed via constant-time transitions.

Total time: $O(n^2)$ per test case.  
Space: $O(n)$ for the rolling DP arrays plus $O(n)$ for `sorted_auras`.

---

**6. Conclusion**

Because the taken artifacts always form a contiguous interval in the sorted
lineup, each prefix spread depends only on the interval endpoints. This enables
an interval DP with two transitions per state, yielding an $O(n^2)$ solution
that correctly handles negative weights and maximizes the weighted score.